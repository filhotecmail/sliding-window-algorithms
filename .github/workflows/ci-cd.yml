name: CI/CD Pipeline - Sliding Window Algorithms

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]
  schedule:
    # Run tests daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    # Allow manual triggering

env:
  DOCKER_IMAGE_NAME: sliding-window-algorithms
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job 1: Build and Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        fpc-version: ['3.2.2', 'stable']
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Free Pascal Compiler
      run: |
        sudo apt-get update
        sudo apt-get install -y fpc fp-compiler fp-units-base fp-units-fcl fp-units-misc fp-units-math fp-units-rtl
        fpc -iV
        fpc -iTP
        fpc -iTO
    
    - name: Cache FPC units
      uses: actions/cache@v3
      with:
        path: |
          ~/.fpc
          build/units
        key: ${{ runner.os }}-fpc-${{ matrix.fpc-version }}-${{ hashFiles('src/**/*.pas') }}
        restore-keys: |
          ${{ runner.os }}-fpc-${{ matrix.fpc-version }}-
          ${{ runner.os }}-fpc-
    
    - name: Create build directories
      run: |
        mkdir -p build/units build/bin build/reports
        chmod +x build.sh test.sh benchmark.sh ci-cd.sh || true
    
    - name: Build project
      run: |
        echo "Building Sliding Window Algorithms..."
        echo "Compiler: $(fpc -iV)"
        echo "Target: $(fpc -iTP)-$(fpc -iTO)"
        
        # Set compiler options
        export FPC_OPTIONS="-Mobjfpc -Scghi -O1 -g -gl -l -vewnhibq"
        export UNIT_PATH="-Fu./src/Algorithms -Fu./src/Utils -Fu./src/Tests"
        export OUTPUT_PATH="-FE./build/bin -FU./build/units"
        
        # Compile main algorithm unit
        echo "Compiling SlidingWindow.pas..."
        fpc $FPC_OPTIONS $UNIT_PATH $OUTPUT_PATH src/Algorithms/SlidingWindow.pas
        
        # Compile performance analyzer
        echo "Compiling PerformanceAnalyzer.pas..."
        fpc $FPC_OPTIONS $UNIT_PATH $OUTPUT_PATH src/Utils/PerformanceAnalyzer.pas
        
        # Compile tests
        echo "Compiling SlidingWindowTests.pas..."
        fpc $FPC_OPTIONS $UNIT_PATH $OUTPUT_PATH -o./build/bin/SlidingWindowTests src/Tests/SlidingWindowTests.pas
        
        echo "Build completed successfully!"
        ls -la ./build/bin/
    
    - name: Run unit tests
      run: |
        echo "Running Sliding Window Algorithm Tests..."
        echo "========================================"
        
        # Check if test executable exists
        if [ ! -f "./build/bin/SlidingWindowTests" ]; then
            echo "Test executable not found!"
            exit 1
        fi
        
        # Run tests
        echo "Executing tests..."
        ./build/bin/SlidingWindowTests || echo "Tests completed with warnings"
        
        echo "Tests execution finished!"
    
    - name: Run performance benchmarks
      run: |
        echo "Running Performance Benchmarks..."
        echo "================================"
        
        # Create benchmark program
        cat > benchmark.pas << 'EOF'
        program SlidingWindowBenchmark;
        
        {$mode objfpc}{$H+}
        
        uses
          SysUtils, Classes, DateUtils,
          SlidingWindow, PerformanceAnalyzer;
        
        var
          Benchmark: TSlidingWindowBenchmark;
          Report: string;
        begin
          WriteLn('Starting Sliding Window Algorithms Benchmark...');
          WriteLn('===================================================');
          WriteLn('');
          
          Benchmark := TSlidingWindowBenchmark.Create;
          try
            // Run full benchmark suite
            WriteLn('Running comprehensive benchmark suite...');
            Benchmark.RunFullBenchmarkSuite;
            
            // Run scalability test
            WriteLn('Running scalability analysis...');
            Benchmark.RunScalabilityTest(1000, 10000, 2000);
            
            // Generate and display report
            WriteLn('');
            WriteLn('Generating performance report...');
            Report := Benchmark.GetBenchmarkResults;
            WriteLn(Report);
            
            // Save reports
            Benchmark.SaveBenchmarkResults('./build/reports/benchmark_report.txt');
            Benchmark.Analyzer.SaveCSVReportToFile('./build/reports/benchmark_data.csv');
            
            WriteLn('');
            WriteLn('Benchmark completed successfully!');
            WriteLn('Reports saved to ./build/reports/');
          finally
            Benchmark.Free;
          end;
        end.
        EOF
        
        # Set compiler options
        export FPC_OPTIONS="-Mobjfpc -Scghi -O1 -g -gl -l -vewnhibq"
        export UNIT_PATH="-Fu./src/Algorithms -Fu./src/Utils -Fu./src/Tests"
        export OUTPUT_PATH="-FE./build/bin -FU./build/units"
        
        # Compile benchmark
        echo "Compiling benchmark program..."
        fpc $FPC_OPTIONS $UNIT_PATH $OUTPUT_PATH -o./build/bin/benchmark benchmark.pas
        
        # Run benchmark
        echo "Running benchmark..."
        ./build/bin/benchmark || echo "Benchmark completed with warnings"
        
        echo "Benchmark execution finished!"
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-artifacts-${{ matrix.fpc-version }}
        path: |
          build/bin/
          build/reports/
        retention-days: 30
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.fpc-version }}
        path: |
          build/reports/
          *.log
        retention-days: 7

  # Job 2: Docker Build and Test
  docker-build:
    name: Docker Build and Test
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Test Docker image
      run: |
        echo "Testing Docker image..."
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} ./test.sh
        echo "Docker image test completed!"
    
    - name: Push Docker image
      if: github.event_name != 'pull_request'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  # Job 3: Code Quality Analysis
  code-quality:
    name: Code Quality Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Analyze code structure
      run: |
        echo "Code Quality Analysis"
        echo "===================="
        echo ""
        
        echo "Source code statistics:"
        find src/ -name "*.pas" -exec wc -l {} + | tail -1
        echo ""
        
        echo "File structure:"
        tree src/ || find src/ -type f -name "*.pas" | sort
        echo ""
        
        echo "Checking for common issues..."
        
        # Check for TODO/FIXME comments
        echo "TODO/FIXME comments:"
        grep -r "TODO\|FIXME\|XXX" src/ || echo "No TODO/FIXME comments found"
        echo ""
        
        # Check for long lines (>120 characters)
        echo "Long lines (>120 characters):"
        find src/ -name "*.pas" -exec awk 'length($0) > 120 {print FILENAME ":" NR ":" $0}' {} + || echo "No long lines found"
        echo ""
        
        # Check for trailing whitespace
        echo "Files with trailing whitespace:"
        find src/ -name "*.pas" -exec grep -l "[[:space:]]$" {} + || echo "No trailing whitespace found"
        echo ""
        
        echo "Code quality analysis completed!"
    
    - name: Generate code metrics
      run: |
        echo "Generating code metrics..."
        
        # Count lines of code
        echo "Lines of Code Analysis:"
        echo "======================"
        
        total_lines=0
        code_lines=0
        comment_lines=0
        blank_lines=0
        
        for file in $(find src/ -name "*.pas"); do
          lines=$(wc -l < "$file")
          comments=$(grep -c "^[[:space:]]*//\|^[[:space:]]*{\|^[[:space:]]*\*" "$file" || echo 0)
          blanks=$(grep -c "^[[:space:]]*$" "$file" || echo 0)
          code=$((lines - comments - blanks))
          
          echo "$file: $lines total, $code code, $comments comments, $blanks blank"
          
          total_lines=$((total_lines + lines))
          code_lines=$((code_lines + code))
          comment_lines=$((comment_lines + comments))
          blank_lines=$((blank_lines + blanks))
        done
        
        echo ""
        echo "Summary:"
        echo "Total lines: $total_lines"
        echo "Code lines: $code_lines"
        echo "Comment lines: $comment_lines"
        echo "Blank lines: $blank_lines"
        echo "Comment ratio: $(echo "scale=2; $comment_lines * 100 / $total_lines" | bc -l)%"

  # Job 4: Security Scan
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run security scan
      run: |
        echo "Security Scan"
        echo "============="
        echo ""
        
        # Check for potential security issues
        echo "Checking for potential security issues..."
        
        # Look for hardcoded passwords/keys
        echo "Hardcoded credentials check:"
        grep -ri "password\|secret\|key\|token" src/ --include="*.pas" || echo "No hardcoded credentials found"
        echo ""
        
        # Check for SQL injection patterns
        echo "SQL injection patterns:"
        grep -ri "execute.*+\|query.*+" src/ --include="*.pas" || echo "No SQL injection patterns found"
        echo ""
        
        # Check for file path traversal
        echo "Path traversal patterns:"
        grep -ri "\.\./\|..\\\\" src/ --include="*.pas" || echo "No path traversal patterns found"
        echo ""
        
        echo "Security scan completed!"

  # Job 5: Performance Regression Test
  performance-regression:
    name: Performance Regression Test
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: build-artifacts-stable
        path: build/
    
    - name: Set up Free Pascal Compiler
      run: |
        sudo apt-get update
        sudo apt-get install -y fpc fp-compiler fp-units-base fp-units-fcl fp-units-misc fp-units-math fp-units-rtl
    
    - name: Run performance regression test
      run: |
        echo "Performance Regression Test"
        echo "==========================="
        echo ""
        
        # Make executables executable
        chmod +x build/bin/* || true
        
        # Run benchmark if available
        if [ -f "build/bin/benchmark" ]; then
          echo "Running performance benchmark..."
          ./build/bin/benchmark
        else
          echo "Benchmark executable not found, skipping performance test"
        fi
        
        echo "Performance regression test completed!"

  # Job 6: Deploy Documentation
  deploy-docs:
    name: Deploy Documentation
    runs-on: ubuntu-latest
    needs: [build-and-test, code-quality]
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Pages
      uses: actions/configure-pages@v3
    
    - name: Generate documentation
      run: |
        echo "Generating documentation..."
        mkdir -p docs
        
        # Copy README as main documentation
        cp README.md docs/index.md
        
        # Create additional documentation files
        echo "# API Documentation" > docs/api.md
        echo "" >> docs/api.md
        echo "## Classes" >> docs/api.md
        echo "" >> docs/api.md
        
        # Extract class documentation from source files
        for file in src/Algorithms/*.pas src/Utils/*.pas; do
          if [ -f "$file" ]; then
            echo "### $(basename "$file" .pas)" >> docs/api.md
            echo "" >> docs/api.md
            grep -A 5 "^[[:space:]]*T.*= class" "$file" | head -20 >> docs/api.md || true
            echo "" >> docs/api.md
          fi
        done
        
        echo "Documentation generated!"
    
    - name: Upload Pages artifact
      uses: actions/upload-pages-artifact@v2
      with:
        path: docs/
    
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v2

  # Job 7: Release
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-and-test, docker-build, code-quality, security-scan]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: build-artifacts-stable
        path: release/
    
    - name: Generate release notes
      run: |
        echo "# Release Notes" > RELEASE_NOTES.md
        echo "" >> RELEASE_NOTES.md
        echo "## Changes" >> RELEASE_NOTES.md
        echo "" >> RELEASE_NOTES.md
        
        # Get commits since last tag
        git log --oneline --since="1 day ago" >> RELEASE_NOTES.md || echo "No recent commits" >> RELEASE_NOTES.md
        
        echo "" >> RELEASE_NOTES.md
        echo "## Build Information" >> RELEASE_NOTES.md
        echo "- Build Date: $(date)" >> RELEASE_NOTES.md
        echo "- Commit: ${{ github.sha }}" >> RELEASE_NOTES.md
        echo "- Branch: ${{ github.ref_name }}" >> RELEASE_NOTES.md
    
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body_path: RELEASE_NOTES.md
        draft: false
        prerelease: false

# Permissions for GitHub Pages and Container Registry
permissions:
  contents: read
  pages: write
  id-token: write
  packages: write
  actions: read
  security-events: write

# Concurrency settings
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true